/*
 * Copyright (C) 2009 The Sipdroid Open Source Project
 * 
 * This file is part of Sipdroid (http://www.sipdroid.org)
 * 
 * Sipdroid is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This source code is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this source code; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package com.jiaxun.sdk.scl.media.audio;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

import android.app.ActionBar.Tab;

import com.jiaxun.sdk.scl.session.SessionManager;
import com.jiaxun.sdk.util.config.CommonConfigEntry;
import com.jiaxun.sdk.util.log.Log;

// Simple class to support call recording.
public class CallRecorder
{
    // True if we have finished writing the outgoing stream.
    boolean outgoingStopped = false;
    // True if we have finished the incoming one. When both true the output file
    // is closed.
    boolean incomingStopped = false;
    // The output wav file.
    WavWriter callWav = null;

    WavWriter callRecordWav = null;// 采集音频
    WavWriter callTrackWav = null;// 播放音频

    // 上行录音文件名
    private static String recordeFileName = "-record.wav";
    // 下行录音文件名
    private static String trackFileName = "-track.wav";
    // 录音文件名
    private static String fileName = ".wav";
    /** 日期格式    */
    private static SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");

    // Filename is without the /sdcard/Ripdroid, or the .wav ending.
    // If null it is autogenerated from the current time/date.
    // Existing files are silently overwritten!
    public CallRecorder(String filename, int sample_rate)
    {
        if (filename == null)
        {
            // Create filename from current date.
            filename = sdf.format(new Date());
        }

        // Make sure directory exists.
        File dir = new File(CommonConfigEntry.TEST_RECORDEINGS_PATH);
        dir.mkdirs();

//		if(CommonConfigEntry.TEST_RECORDEINGS_RECORD)
//		{//上行录音
//		    callRecordWav = new WavWriter(CommonConfigEntry.TEST_RECORDEINGS_PATH + filename + recordeFileName, sample_rate);
//		}
//		if(CommonConfigEntry.TEST_RECORDEINGS_TRACK)
//		{//下行录音
//			callTrackWav = new WavWriter(CommonConfigEntry.TEST_RECORDEINGS_PATH + filename + trackFileName, sample_rate);
//		}
//		if(CommonConfigEntry.TEST_RECORDEINGS)
        // If this fails, all of the other calls just silently return
        // immediately.
        if (SessionManager.getInstance().getServiceConfig().isAudioRecord)
        {// 上下行录音
            Log.info("CallRecorder", "new WavWriter");
            callWav = new WavWriter(CommonConfigEntry.TEST_RECORDEINGS_PATH + filename + fileName, sample_rate);
        }
    }

    // Write data received from the internet.
    public void writeIncoming(short[] buffer, int offs, int len)
    {
        if (callWav != null)
        {
            callWav.writeLeft(buffer, offs, len);
        }
        if (callTrackWav != null)
        {
            callTrackWav.writeLeft(buffer, offs, len);
        }
    }

    // Write audio from the mic.
    public void writeOutgoing(short[] buffer, int offs, int len)
    {
        if (callWav != null)
        {
            callWav.writeRight(buffer, offs, len);
        }
        if (callRecordWav != null)
        {
            callRecordWav.writeRight(buffer, offs, len);
        }
    }

    // We won't write any more incoming data.
    public void stopIncoming()
    {
        incomingStopped = true;
        checkClose();
    }

    // We won't write any more outgoing data.
    public void stopOutgoing()
    {
        outgoingStopped = true;
        checkClose();
    }

    // Check to see if no more data will be written. If so close the wav file.
    private void checkClose()
    {
        if (!outgoingStopped || !incomingStopped)
            return;

        if (callWav != null)
        {
            callWav.close();
            callWav = null;
        }

        if (callRecordWav != null)
        {
            callRecordWav.close();
            callRecordWav = null;
        }

        if (callTrackWav != null)
        {
            callTrackWav.close();
            callTrackWav = null;
        }
    }
}
